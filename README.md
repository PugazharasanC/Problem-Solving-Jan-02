# Summary:
1. Day 1: Basic problem solving, math operations, and string manipulation.
1. Day 2: Recursion and searching algorithms (linear and binary search).
1. Day 3: Advanced array operations and sorting algorithms.
1. Day 4: Stacks, queues, and linked list operations.
1. Day 5: Trees, BST, and recursion-based problems.
1. Day 6: Recursion, sliding window, and hashing techniques.

# Day 1: Problem Statements, Basic Math, and Strings
## Key Topics: Problem interpretation, basic math operations, string manipulation.
## Session Focus:
- Learn to interpret problem statements and break them down into actionable steps.
- Basic math operations: positive/negative numbers, sum, and other simple calculations.
- String manipulation: reversal, checking alphabets, and counting characters.
## Session Practice Questions:
1. Determine if a number is positive or negative.
1. Find the sum of two integers.
1. Identify the maximum and minimum of three numbers.
1. Count the number of digits in a number.
1. Check if a string contains only alphabets.
## Post-session Practice Questions:
1. Calculate the difference between two integers.
1. Check if a number is even or odd.
1. Calculate the perimeter of a rectangle.
1. Find the largest of four numbers.
1. Calculate the average of three numbers.
1. Identify if a number is divisible by both 3 and 5.
1. Count the number of vowels in a string.
1. Determine if a character is an uppercase letter.
1. Print the reverse of a string.
1. Find the square of a number.

# Day 2: Recursion & Searching Algorithms
## Key Topics: Recursion, linear and binary search, and basic search operations.
## Session Focus:
Understand recursion and solve problems like factorials and Fibonacci.
Learn linear and binary search techniques to find elements in arrays.
Practice simple search-based problems.
## Session Practice Questions:
Calculate the factorial of a number recursively.
Implement linear search to find an element in an array.
Implement binary search on a sorted array.
Find the first and last occurrence of a target in an array.
Search for a target in a rotated sorted array.
## Post-session Practice Questions:
1. Count occurrences of a target using binary search.
1. Find the index where an element should be inserted in a sorted array.
1. Find the peak element in a mountain array.
1. Find the smallest missing element in a sorted array.
1. Find the floor and ceiling of a target in a sorted array.
1. Perform ternary search on a sorted array.
1. Find the index of a target in an infinite array.
1. Find the closest element to a target in a sorted array.
1. Find the peak index in a bitonic array.
1. Implement an exponential search.

# Day 3: Arrays & Array Methods
## Key Topics: Arrays, rotations, sorting, searching, and manipulation.
## Session Focus:
Array manipulation: rotating arrays, finding the second-largest element, and array sums.
Sorting basics: bubble sort, selection sort.
Removing duplicates from arrays and basic search operations.
## Session Practice Questions:
Rotate an array by one position.
Find the second-largest element in an array.
Remove duplicates from a sorted array.
Calculate the sum of elements in an array.
Find the number of occurrences of an element in an array.
## Post-session Practice Questions:
1. Merge two sorted arrays.
1. Reverse the elements in an array.
1. Rotate an array to the left by K positions.
1. Find the cumulative sum of an array.
1. Calculate the product of all elements in an array.
1. Check if an array is a palindrome.
1. Find the intersection of two arrays.
1. Search for an element in a sorted array.
1. Find the difference between the maximum and minimum elements.
1. Find the element with the second-largest frequency.

# Day 4: Stacks, Queues, and Linked Lists
## Key Topics: Stacks, queues, linked lists, and related operations.
## Session Focus:
Learn stack and queue operations: implementing stacks using arrays, checking for balanced parentheses, and reversing strings using stacks.
Linked list operations: insertion, deletion, reversing, and detecting cycles in linked lists.
## Session Practice Questions:
Implement a stack using an array.
Reverse a string using a stack.
Check for balanced parentheses in an expression.
Insert a node at the beginning of a linked list.
Delete the last node in a linked list.
## Post-session Practice Questions:
1. Reverse a linked list iteratively.
1. Detect a cycle in a linked list using fast and slow pointers.
1. Merge two sorted linked lists.
1. Remove duplicates from a sorted linked list.
1. Check if a linked list is a palindrome.
1. Implement a priority queue.
1. Reverse the first k elements of a queue.
1. Implement a circular queue.
1. Find the middle element of a linked list.
1. Clone a linked list with random pointers.

# Day 5: Trees, Binary Search Trees (BST), and Recursion
## Key Topics: Trees, binary search trees (BST), tree traversals, recursion techniques.
## Session Focus:
Learn about binary trees and binary search trees: traversals (pre-order, in-order, post-order), finding LCA (lowest common ancestor), and tree height.
Recursive approaches for tree-related problems.
## Session Practice Questions:
Find the height of a binary tree.
Perform a pre-order traversal of a binary tree.
Check if a binary tree is a binary search tree (BST).
Find the lowest common ancestor (LCA) of two nodes in a BST.
Count the number of leaf nodes in a binary tree.
## Post-session Practice Questions:
1. Perform an in-order traversal iteratively.
1. Find the diameter of a binary tree.
1. Check if two binary trees are identical.
1. Convert a binary tree to a doubly linked list.
1. Construct a binary tree from its inorder and preorder traversals.
1. Print all nodes at k distance from the root.
1. Serialize and deserialize a binary tree.
1. Find the level with the maximum sum in a binary tree.
1. Calculate the depth of the deepest leaf node.
1. Convert a BST to a balanced BST.

# Day 6: Recursion, Sliding Window, Two Pointers, and Hashing
## Key Topics: Recursion, sliding window, and hashing.
## Key Focus:
Learn recursive problem-solving approaches for problems like factorial, Fibonacci, and palindrome checking.
Understand sliding window techniques for finding subarrays and substrings.
Hashing for tracking counts, finding duplicates, and other problems.
## Key Practice Questions:
Calculate the factorial of a number recursively.
Find the nth Fibonacci number using recursion.
Check if a string is a palindrome using recursion.
Find the length of the longest substring without repeating characters (sliding window).
Implement a recursive binary search.
## Post-session Practice Questions:
1. Solve the Tower of Hanoi problem.
1. Reverse a string recursively.
1. Count the number of ways to climb stairs (1 or 2 steps at a time).
1. Find the longest subarray with equal 0s and 1s.
1. Find all triplets in an array that sum up to zero.
1. Find the first missing positive integer in an array.
1. Find the longest mountain in an array.
1. Merge two sorted arrays without using extra space.
1. Find the first non-repeating character in a string.
1. Find the longest substring with exactly k distinct characters.


